\lhead{\emph{Implementation}}

% ***************************************************************************
\chapter{Implementation}
% ***************************************************************************

\section{Preprocessing}

\subsection{Downsampling}

The first thing that appears is that point clouds are really heavy data structures and processing them will require a huge amount of computation power. To be able to perform fast computation on point clouds I started by sub-sampling the point clouds to reduce the number of points. \\
Several techniques can be used to downsample a point cloud. Some of them focus more on some region considered as more crucial (edges, corners etc.), these methods are usually used to decrease the number of points before extracting keypoints, when it is expected them to match with other similar points in another cloud. Here I decided to use the simplest one which is a regular downsampling, indeed I will use all points to estimate planes equation not only remarkable points. \\
\newline
Sub-sampling allow to significantly decrease the size of the data to process by picking equally spaced points which makes the final result keeping most of the information we need in the point cloud. The sub-sampling size can be chosen to adapt the precision/performance ratio.

\subsection{Cutting}

Another way to reduce the point cloud size could be to cut it to remove non useful parts. This obviously requires to have some knowledge of the information received by the camera and will not be applicable in the case of a new unknown scene. However, cutting the point cloud will helps to quickly implement some registration techniques and will be used for testing and debugging purpose. \\
In this example I cut the point cloud to keep only the points inside the working area.

\subsection{Filtering}

Finally, point cloud filtering is also a way I considered to decrease the size of the point cloud. I used radius filtering to delete outliers (points that don’t have enough neighbors inside a chosen radius). However this filtering was needing a lot of computation time compared to the small improvement it provides in this case. I no longer use this filtering in the preprocessing stage. 

\subsection{Plane Detection}

The first step is to extract planes from the point clouds. I am using RANSAC algorithm to detect the most relevant plane of the cloud. Then by subtracting the corresponding points from the point cloud I apply again the RANSAC algorithm, by iterating this steps I can extract as many planes as needed and they are extracted by order of size. The idea is then to apply this plane detection on each point cloud in order to match these planes between both clouds. For testing purpose, in order not to spend much time trying to match the planes which is a difficult problem, I cut the input point clouds in a convenient way so that the planes are detected in the same order in both cameras. 

\subsection{Plane Matching}

The plane matching is the task of matching as many planes as possible between different cameras. These planes should be matched when they correspond to the same equation (for computing translation and rotation part of the transform) or when they are parallel (for computing rotation only). In the previous sections I simplified this problem using knowledge from the scene to ensure, by construction, that planes are extracted in the same order so that this plane matching step, is not useful in this case. These assumptions restrains me to extract only the biggest planes of the scene has the table and wall (but not the smallest ones that can’t be matched that easily). As a consequence I can directly implement the plane registration algorithm to get some results but this makes my registration not to be robust at all to camera displacement, occlusion etc. The plane matching part will have to be considered for making this work as expected. however, as this matching is probably the most challenging part, this simplification allows me to finishing the registration and get some results in this particular case. If these results are convincing, I will focus on plane matching for extending this technique to unknown scenes in a more robust and automated way than the currently implemented solution.

\subsection{Plane registration}

I extract with the plane detector, normal vector and distance to origin for every plane detected in the point clouds. The registration part consists in finding the transformation that best move vectors from one camera match the second one. \newline
As presented in \cite{Khoshelham2016}, this problem can be solved by minimizing the distances between planes after applying the transform. \newline
If we define a plane as the vector $\pi=(n^T, -\rho)$ (normal vector and distance to origin) that satisfy for every point $p$ of this plane the equation:
\[\pi p=0\]
And let $H$ be the transform between point clouds A and B such that:
\[p^B = Hp^A\]
We can define $H'$ the transform that brings any plane equation in A $\pi^A$ to its corresponding plane in point cloud B $\pi^{B}$. We can demonstrate that: \[H'=H^-T\]
Finding $H$ is then the same as finding $H'$ that minimize plane distances: \[\pi^B_i=H'\pi^A_i\]
If we write: 
\[H'=\begin{bmatrix}
R & t\\ 
0 & 1
\end{bmatrix}\]
We then have for each matching planes:
\[\left\{\begin{matrix}
{n_i^B}^TR={n_i^A}^T\\ 
{n_i^B}^Tt=\rho_i^B-\rho_i^A
\end{matrix}\right.\]
By stacking all $n$ vectors into a matrix $N$ and all $\rho_i^B-\rho_i^A$ into a vector $d$, the problem became:
\[\left\{\begin{matrix}
N^BR=N^A\\ 
N^Bt=d
\end{matrix}\right.\]
We can then simply compute the least square solutions for any n-dimensional distance metric where n is the number of matches. Especially, a useful metric could be for any n-d weight matrix $W$:
\[\mathcal{D}(x,y)=a^TWb\]
This metric will allow to weight some planes differently according to the confidence we give to the precision of their plane detection, otherwise $W=I_n$ will be used.
The final solution is:
\[\left\{\begin{matrix}
\tilde{t}=({N^B}^TWN^B)^{-1}{N^B}^TWd\\ 
\tilde{R}=({N^B}^TWN^B)^{-1}{N^B}^TWN^A
\end{matrix}\right.\]

At the end we can then ensure the orthogonality of $R$ using SVD decomposition.