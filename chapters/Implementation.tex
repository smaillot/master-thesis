\lhead{\emph{Implementation}}

% ***************************************************************************
\chapter{Implementation}
% ***************************************************************************

\section{Preprocessing}

\subsection{Downsampling}

The first thing that appears is that point clouds are really heavy data structures and processing them will require a huge amount of computation power. To be able to perform fast computation on point clouds I started by sub-sampling the point clouds to reduce the number of points. \\
Several techniques can be used to downsample a point cloud. Some of them focus more on some region considered as more crucial (edges, corners etc.), these methods are usually used to decrease the number of points before extracting keypoints, when it is expected them to match with other similar points in another cloud. Here I decided to use the simplest one which is a regular downsampling, indeed I will use all points to estimate planes equation not only remarkable points. \\
\newline
Sub-sampling allow to significantly decrease the size of the data to process by picking equally spaced points which makes the final result keeping most of the information we need in the point cloud. The sub-sampling size can be chosen to adapt the precision/performance ratio.

\subsection{Cutting}

Another way to reduce the point cloud size could be to cut it to remove non useful parts. This obviously requires to have some knowledge of the information received by the camera and will not be applicable in the case of a new unknown scene. However, cutting the point cloud will helps to quickly implement some registration techniques and will be used for testing and debugging purpose. \\
In this example I cut the point cloud to keep only the points inside the working area.

\subsection{Filtering}

Finally, point cloud filtering is also a way I considered to decrease the size of the point cloud. I used radius filtering to delete outliers (points that donâ€™t have enough neighbors inside a chosen radius). However this filtering was needing a lot of computation time compared to the small improvement it provides in this case. I no longer use this filtering in the preprocessing stage. 

\section{Plane Detection}

The first step is to extract planes from the point clouds. I am using RANSAC algorithm to detect the most relevant plane of the cloud. Then by subtracting the corresponding points from the point cloud I apply again the RANSAC algorithm, by iterating this steps I can extract as many planes as needed and they are extracted by order of size. The idea is then to apply this plane detection on each point cloud in order to match these planes between both clouds. 

\section{Plane Matching}

The plane matching is the task of matching as many planes as possible between different cameras. These planes should be matched when they correspond to the same plane in the real scene. \\
As explained for the implementation of the plane matching registration, I first tried to use global descriptors for this task. However, in our case, planes are too similar and this method is not consistently matching planes. \\
A simpler but still efficient way I implemented this matching was using planes normals and matching planes with the more similar orientation. This way, as long as both point clouds are not built from 2 sensors with completely different orientation, the matching will be done correctly. To avoid wrong matching when cameras are flipped, a previous step to find a rough estimation of the transform may be needed.

\section{Transform Estimation}

I extract with the plane detector, normal vector and distance to origin for every plane detected in the point clouds. The registration part consists in finding the transformation that best move vectors from one camera match the second one. \newline
As presented in \cite{Khoshelham2016}, this problem can be solved by minimizing the distances between planes after applying the transform. \newline
If we define a plane as the vector $\pi=(n^T, -\rho)$ (normal vector and distance to origin) that satisfy for every point $p$ of this plane the equation:
\[\pi p=0\]
And let $H$ be the transform between point clouds A and B such that:
\[p^B = Hp^A\]
We can define $H'$ the transform that brings any plane equation in A $\pi^A$ to its corresponding plane in point cloud B $\pi^{B}$. We can demonstrate that: \[H'=H^-T\]
Finding $H$ is then the same as finding $H'$ that minimize plane distances: \[\pi^B_i=H'\pi^A_i\]
If we write:
\[H'=\begin{bmatrix}
R & t\\ 
0 & 1
\end{bmatrix}\]
We then have for each matching planes:
\[\left\{\begin{matrix}
{n_i^B}^TR={n_i^A}^T\\ 
{n_i^B}^Tt=\rho_i^B-\rho_i^A
\end{matrix}\right.\]
By stacking all $n$ vectors into a matrix $N$ and all $\rho_i^B-\rho_i^A$ into a vector $d$, the problem became:
\[\left\{\begin{matrix}
N^BR=N^A\\ 
N^Bt=d
\end{matrix}\right.\]
We can then simply compute the least square solutions for any n-dimensional distance metric where n is the number of matches. Especially, a useful metric could be for any n-d weight matrix $W$:
\[\mathcal{D}(x,y)=a^TWb\]
This metric will allow to weight some planes differently according to the confidence we give to the precision of their plane detection, otherwise $W=I_n$ will be used.
The final solution is:
\[\left\{\begin{matrix}
\tilde{t}=({N^B}^TWN^B)^{-1}{N^B}^TWd\\ 
\tilde{R}=({N^B}^TWN^B)^{-1}{N^B}^TWN^A
\end{matrix}\right.\]

At the end we can then ensure the orthogonality of $R$ using SVD decomposition.

\section{Program Structure}