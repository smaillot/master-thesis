\lhead{\emph{Implementation}}

% ***************************************************************************
\chapter{Implementation}
% ***************************************************************************

\section{Preprocessing}

\subsection{Downsampling}

The first thing that appears is that point clouds are really heavy data structures and processing them will require a huge amount of computation power. To be able to perform fast computation on point clouds I started by sub-sampling the point clouds to reduce the number of points. \\
Several techniques can be used to downsample a point cloud. Some of them focus more on some region considered as more crucial (edges, corners etc.), these methods are usually used to decrease the number of points before extracting keypoints, when it is expected them to match with other similar points in another cloud. Here I decided to use the simplest one which is a regular downsampling, indeed I will use all points to estimate planes equation not only remarkable points. \\
\newline
Sub-sampling allow to significantly decrease the size of the data to process by picking equally spaced points which makes the final result keeping most of the information we need in the point cloud. The sub-sampling size can be chosen to adapt the precision/performance ratio.

\subsection{Cutting}

Another way to reduce the point cloud size could be to cut it to remove non useful parts. This obviously requires to have some knowledge of the information received by the camera and will not be applicable in the case of a new unknown scene. However, cutting the point cloud will helps to quickly implement some registration techniques and will be used for testing and debugging purpose. \\
In this example I cut the point cloud to keep only the points inside the working area.

\subsection{Filtering}

Finally, point cloud filtering is also a way I considered to decrease the size of the point cloud. I used radius filtering to delete outliers (points that donâ€™t have enough neighbors inside a chosen radius). However this filtering was needing a lot of computation time compared to the small improvement it provides in this case. I no longer use this filtering in the preprocessing stage. 

\section{Plane Detection}

The first step is to extract planes from the point clouds. I am using RANSAC algorithm to detect the most relevant plane of the cloud. Then by subtracting the corresponding points from the point cloud I apply again the RANSAC algorithm, by iterating this steps I can extract as many planes as needed and they are extracted by order of size. The idea is then to apply this plane detection on each point cloud in order to match these planes between both clouds. 

\section{Plane Matching}

The plane matching is the task of matching as many planes as possible between different cameras. These planes should be matched when they correspond to the same plane in the real scene. \\
As explained for the implementation of the plane matching registration, I first tried to use global descriptors for this task. However, in our case, planes are too similar and this method is not consistently matching planes. \\
A simpler but still efficient way I implemented this matching was using planes normals and matching planes with the more similar orientation. This way, as long as both point clouds are not built from 2 sensors with completely different orientation, the matching will be done correctly. To avoid wrong matching when cameras are flipped, a previous step to find a rough estimation of the transform may be needed.

\section{Transform Estimation}

My implementation of transform estimation using both matched points and planes is based on equations derived in \cite{ytaguchi2013}.

\section{Program Structure}